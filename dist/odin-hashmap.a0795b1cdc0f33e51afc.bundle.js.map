{"version":3,"file":"odin-hashmap.a0795b1cdc0f33e51afc.bundle.js","mappings":"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","sources":["webpack://top-javascript-study/./odin-linked-list/linked-list/helpers/node/node.js","webpack://top-javascript-study/./odin-linked-list/linked-list/helpers/is-deeply-equal/is-deeply-equal.js","webpack://top-javascript-study/./odin-linked-list/linked-list/linked-list.js","webpack://top-javascript-study/./odin-hashmap/hashmap/hashmap.js","webpack://top-javascript-study/./odin-hashmap/index.js"],"sourcesContent":["/**\n * Return a node of linked list, containing a value property and a link to the nextNode, set both as null by default.\n * @param {any} value\n * @param {Node?} nextNode\n * @param {Node?} previousNode\n * @returns {Node}\n */\nexport default function Node(\n  value = null,\n  nextNode = null,\n  previousNode = null,\n) {\n  const node = { value };\n  // Store the values locally to mutate their values privately\n  let next = nextNode;\n  let prev = previousNode;\n  // Define next/prev properties freezed and with accessors to get the recent value from locals\n  Object.defineProperties(node, {\n    nextNode: {\n      get: () => next,\n      set() {\n        throw Error('Read-only property (nextNode) cannot be assigned!');\n      },\n      configurable: false,\n      enumerable: true,\n    },\n    previousNode: {\n      get: () => prev,\n      set() {\n        throw Error('Read-only property (nextNode) cannot be assigned!');\n      },\n      configurable: false,\n      enumerable: true,\n    },\n  });\n  // Define a parent object for node to inherit from which setters for next/prev\n  // A, non-enumerable, inherited property couldn't be found (almost hidden) except using 'in' operator\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties#querying_object_properties\n  // this way we make the setters far less approachable to prevent unintended mutations\n  const nodeParent = {};\n  const checkType = (v) => {\n    if (v !== null && !(v instanceof Node)) {\n      throw TypeError(\"Node value must be 'Node' or 'null'!\");\n    }\n    return true;\n  };\n  Object.defineProperties(nodeParent, {\n    setNext: {\n      value: (newNext) => {\n        if (checkType(newNext)) next = newNext;\n      },\n      writable: false,\n      configurable: false,\n      enumerable: false,\n    },\n    setPrev: {\n      value: (newPrev) => {\n        if (checkType(newPrev)) prev = newPrev;\n      },\n      writable: false,\n      configurable: false,\n      enumerable: false,\n    },\n  });\n  Object.setPrototypeOf(nodeParent, Node.prototype); // Make it an instance of Node\n  Object.setPrototypeOf(node, nodeParent); // Inherit from Node instance has setters\n  Object.freeze(nodeParent);\n  Object.seal(node);\n  return node;\n}\n\nObject.freeze(Node.prototype);\n\nexport { Node };\n","// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value\nfunction getCircularReplacer() {\n  const ancestors = [];\n  return function (key, value) {\n    if (typeof value !== 'object' || value === null) {\n      // The ORIGINAL CODE was just:> return value;\n      // BigInt is not serializable, hence JSON.stringify would throw an Error\n      // Here i only convert BigInt to string because of the nature of this use case (just equality)\n      // If i also need to deserialize BigInt, at any point later,\n      // i would put its string version in an object with a special key e.g. {$bigint: String(value)}\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json\n      return typeof value === 'bigint' ? String(value) : value;\n    }\n    // `this` is the object that value is contained in,\n    // i.e., its direct parent.\n    while (ancestors.length > 0 && ancestors.at(-1) !== this) {\n      ancestors.pop();\n    }\n    if (ancestors.includes(value)) {\n      return '[Circular]';\n    }\n    ancestors.push(value);\n    return value;\n  };\n}\n\nexport default function isDeeplyEqual(...args) {\n  if (args.length !== 2) {\n    throw TypeError('Expect exactly 2 arguments!');\n  }\n\n  const first = args[0];\n  const second = args[1];\n\n  if (typeof first !== typeof second) return false; // Deferent types\n\n  if (\n    (typeof first !== 'object' || first === null) &&\n    (typeof second !== 'object' || second === null)\n  ) {\n    // So, 'first' and 'second' not an Array nor an Object\n    return first === second || Object.is(first, second);\n  }\n\n  const firstStringified = JSON.stringify(first, getCircularReplacer());\n  const secondStringified = JSON.stringify(second, getCircularReplacer());\n\n  return firstStringified === secondStringified;\n}\n\nexport { isDeeplyEqual };\n","import Node from './helpers/node';\nimport isDeeplyEqual from './helpers/is-deeply-equal';\n\n/**\n * @module LinkedList\n */\n\n/**\n * Linked list class.\n */\nexport default class LinkedList {\n  #head = null;\n\n  get head() {\n    return this.#head;\n  }\n\n  #tail = null;\n\n  get tail() {\n    return this.#tail;\n  }\n\n  #size = 0;\n\n  get length() {\n    return this.#size;\n  }\n\n  /**\n   * Constructor of LinkedList class. An instance of LinkedList has the following:\n   * - append(value): adds a new node containing value to the end of the list\n   * - prepend(value): adds a new node containing value to the start of the list\n   * - size: returns the total number of nodes in the list\n   * - head: returns the first node in the list\n   * - tail: returns the last node in the list\n   * - at(index): returns the node at the given index\n   * - pop: removes the last element from the list\n   * - contains(value): returns true if the passed in value is in the list and otherwise returns false.\n   * - find(value): returns the index of the node containing value, or null if not found.\n   * - toString: represents your LinkedList objects as strings, so you can print them out and preview them in the console.\n   *   The format should be: ( value ) -> ( value ) -> ( value ) -> null\n   * - insertAt(value, index): that inserts a new node with the provided value at the given index.\n   * - removeAt(index): that removes the node at the given index.\n   * @param  {...any} values - Any number of any values to fill the instance with.\n   * @returns {LinkedList}\n   */\n  constructor(...values) {\n    // If there is any given values, fill the list with them\n    if (values.length > 0) {\n      values.forEach((v) => this.append(v));\n    }\n  }\n\n  append(...values) {\n    // Adds a new node containing value to the end of the list\n    values.forEach((value) => {\n      if (this.#size === 0) {\n        this.#head = Node(value);\n        this.#tail = this.#head;\n      } else if (this.#size === 1) {\n        this.#tail = Node(value, null, this.#head);\n        this.#head.setNext(this.#tail);\n      } else {\n        const node = Node(value, null, this.#tail);\n        this.#tail.setNext(node);\n        this.#tail = node;\n      }\n      this.#size++;\n    });\n    return this;\n  }\n\n  prepend(...values) {\n    // Adds a new node containing value to the start of the list\n    for (let i = values.length - 1; i >= 0; i--) {\n      const value = values[i];\n      if (this.#size === 0) {\n        this.#head = Node(value);\n        this.#tail = this.#head;\n      } else if (this.#size === 1) {\n        this.#head = Node(value, this.#tail);\n        this.#tail.setPrev(this.#head);\n      } else {\n        const node = Node(value, this.#head);\n        this.#head.setPrev(node);\n        this.#head = node;\n      }\n      this.#size++;\n    }\n    return this;\n  }\n\n  at(index) {\n    // Returns the node at the given index\n    let i = Number(index);\n    if (\n      !Number.isInteger(i) ||\n      (i > -1 && i > this.#size - 1) ||\n      (i < 0 && Math.abs(i) > this.#size)\n    ) {\n      throw Error('Invalid index!');\n    }\n    if (this.#size === 0) throw Error('The linked list is empty!');\n    if (i < 0) {\n      let node = this.#tail;\n      while (i < -1) {\n        node = node.previousNode;\n        i++;\n      }\n      return node;\n    }\n    let node = this.#head;\n    while (i > 0) {\n      node = node.nextNode;\n      i--;\n    }\n    return node;\n  }\n\n  contains(value) {\n    // Returns true if the passed in value is in the list and otherwise returns false.\n    let node = this.#head;\n    while (node !== null) {\n      if (isDeeplyEqual(node.value, value)) {\n        return true;\n      }\n      node = node.nextNode;\n    }\n    return false;\n  }\n\n  pop() {\n    // Removes the last element from the list\n    if (this.#size === 0) return null;\n    const removedNode = Node(this.#tail.value);\n    if (this.#size === 1) {\n      this.#head = null;\n      this.#tail = this.#head;\n    } else {\n      this.#tail = this.#tail.previousNode;\n      this.#tail.setNext(null);\n    }\n    this.#size--;\n    return removedNode;\n  }\n\n  shift() {\n    // Removes the first element from the list\n    if (this.#size === 0) return null;\n    const removedNode = Node(this.#head.value);\n    if (this.#size === 1) {\n      this.#head = null;\n      this.#tail = this.#head;\n    } else {\n      this.#head = this.#head.nextNode;\n      this.#head.setPrev(null);\n    }\n    this.#size--;\n    return removedNode;\n  }\n\n  find(value) {\n    // Returns the index of the node containing value, or null if not found.\n    let i = 0;\n    let node = this.#head;\n    while (node !== null) {\n      if (isDeeplyEqual(node.value, value)) {\n        return i;\n      }\n      i++;\n      node = node.nextNode;\n    }\n    return null;\n  }\n\n  toString() {\n    // Represents your LinkedList objects as strings, so you can print them out and preview them in the console.\n    // The format should be: ( value ) -> ( value ) -> ( value ) -> null\n    let result = 'null';\n    let node = this.#tail;\n    while (node !== null) {\n      result = `( ${node.value} ) -> ${result}`;\n      node = node.previousNode;\n    }\n    return result;\n  }\n\n  insertAt(value, index) {\n    // Inserts a new node with the provided value at the given index.\n    if (\n      !Number.isInteger(index) ||\n      (index > -1 && index > this.#size) ||\n      (index < 0 && Math.abs(index) > this.#size + 1)\n    ) {\n      throw TypeError(\n        `Node index must be an integer in the range of (0 : ${this.#size}) or (-1 : -${this.#size + 1})!`,\n      );\n    }\n    if (this.#size === 0 || (this.#size === 1 && (index > 0 || index === -1))) {\n      this.append(value);\n    } else if (this.#size === 1 && (index === 0 || index < -1)) {\n      this.prepend(value);\n    } else {\n      if (index === 0 || index === (this.#size + 1) * -1) {\n        const nodeAfterHead = this.#head;\n        this.#head = Node(value, nodeAfterHead);\n        nodeAfterHead.setPrev(this.#head);\n      } else if (index === this.#size || index === -1) {\n        const nodeBeforeTail = this.#tail;\n        this.#tail = Node(value, null, nodeBeforeTail);\n        nodeBeforeTail.setNext(this.#tail);\n      } else if (index < 0) {\n        let toBePreviousNode = this.#tail;\n        for (let i = index; i < -1; i++) {\n          toBePreviousNode = toBePreviousNode.previousNode;\n        }\n        const node = Node(value, toBePreviousNode.nextNode, toBePreviousNode);\n        toBePreviousNode.nextNode.setPrev(node);\n        toBePreviousNode.setNext(node);\n      } else {\n        let toBeNextNode = this.#head;\n        for (let i = 0; i < index; i++) {\n          toBeNextNode = toBeNextNode.nextNode;\n        }\n        const node = Node(value, toBeNextNode, toBeNextNode.previousNode);\n        toBeNextNode.previousNode.setNext(node);\n        toBeNextNode.setPrev(node);\n      }\n      this.#size++;\n    }\n    return this;\n  }\n\n  removeAt(index) {\n    // Removes the node at the given index.\n    if (this.#size === 0) return null;\n    if (\n      !Number.isInteger(index) ||\n      (index > -1 && index > this.#size - 1) ||\n      (index < 0 && Math.abs(index) > this.#size)\n    ) {\n      throw Error('Invalid index!');\n    }\n    let node = null;\n    if (index === 0 || index === this.#size * -1) {\n      node = this.#head;\n      this.#head = node.nextNode;\n      if (this.#size > 1) this.#head.setPrev(null);\n    } else if (index === this.#size - 1 || index === -1) {\n      node = this.#tail;\n      this.#tail = node.previousNode;\n      if (this.#size > 1) this.#tail.setNext(null);\n    } else {\n      if (index < 0) {\n        node = this.#tail;\n        for (let i = index; i < -1; i++) {\n          node = node.previousNode;\n        }\n      } else {\n        node = this.#head;\n        for (let i = 0; i < index; i++) {\n          node = node.nextNode;\n        }\n      }\n      node.previousNode.setNext(node.nextNode);\n      node.nextNode.setPrev(node.previousNode);\n    }\n    this.#size--;\n    return node;\n  }\n\n  forEach(func) {\n    if (typeof func !== 'function') {\n      throw TypeError('The given argument must be of type \"function\"!');\n    }\n    let i = 0;\n    let node = this.#head;\n    while (node !== null) {\n      func(node.value, i);\n      node = node.nextNode;\n      i++;\n    }\n  }\n\n  filter(func) {\n    if (typeof func !== 'function') {\n      throw TypeError('The given argument must be of type \"function\"!');\n    }\n    const newList = new LinkedList();\n    let i = 0;\n    let node = this.#head;\n    while (node !== null) {\n      const passed = func(node.value, i);\n      if (typeof passed !== 'boolean') {\n        throw TypeError('The given function must return a \"boolean\" value!');\n      }\n      if (passed) {\n        newList.append(node.value);\n      }\n      node = node.nextNode;\n      i++;\n    }\n    return newList;\n  }\n\n  map(func) {\n    if (typeof func !== 'function') {\n      throw TypeError('The given argument must be of type \"function\"!');\n    }\n    const newList = new LinkedList();\n    let i = 0;\n    let node = this.#head;\n    while (node !== null) {\n      newList.append(func(node.value, i));\n      node = node.nextNode;\n      i++;\n    }\n    return newList;\n  }\n}\n\n// Prevent breaking the prototype of LinkedList class\nObject.freeze(LinkedList); // For static members' prototype\nObject.freeze(LinkedList.prototype); // For instance members' prototype\nObject.freeze(Object.getPrototypeOf(LinkedList)); // For static members' prototype's prototype (just in case :))\n\nexport { LinkedList };\n","import LinkedList from '../../odin-linked-list/linked-list';\n\nexport default class HashMap {\n  static #FACTOR = 0.75;\n\n  static #SCALE = 1.5;\n\n  #buckets = Array(16);\n\n  #entriesCount = 0;\n\n  static get FACTOR() {\n    return HashMap.#FACTOR; // Just to test scaling\n  }\n\n  static get SCALE() {\n    return HashMap.#SCALE; // Just to test scaling\n  }\n\n  get capacity() {\n    return this.#buckets.length; // Just to test scaling\n  }\n\n  get length() {\n    return this.#entriesCount;\n  }\n\n  constructor(...args) {\n    if (args.length > 0) {\n      throw TypeError(`HashMap constructor does not expect any arguments!`);\n    }\n    Object.freeze(this); // Freeze every new instance\n  }\n\n  static #getStringKeyAndValidate(key) {\n    if (typeof key === 'object') {\n      throw TypeError('The \"key\" (first argument) cannot be of TYPE \"object\"');\n    }\n    if (key === '') {\n      throw TypeError('The \"key\" (first argument) cannot be EMPTY \"string\"');\n    }\n    return String(key);\n  }\n\n  static #findNode(bucketLinkedList, key) {\n    let node = bucketLinkedList.head;\n    while (node) {\n      if (node.value.key === key) return node;\n      node = node.nextNode;\n    }\n    return null;\n  }\n\n  #getBucket(index) {\n    if (index < 0 || index >= this.#buckets.length) {\n      throw new Error('Trying to access index out of bound');\n    }\n    return this.#buckets[index];\n  }\n\n  #setBucket(index, nodeListValue) {\n    if (index < 0 || index >= this.#buckets.length) {\n      throw new Error('Trying to access index out of bound');\n    }\n    this.#buckets[index] = nodeListValue;\n  }\n\n  #hash(key) {\n    const PRIME_NUMBER = 31;\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n      hash += (key.charCodeAt(i) * PRIME_NUMBER) % this.#buckets.length;\n    }\n    hash %= this.#buckets.length;\n    return hash;\n  }\n\n  #scaleUpIfNeeded() {\n    if (this.#entriesCount / this.#buckets.length > HashMap.#FACTOR) {\n      const entries = this.entries();\n      this.#buckets = Array(Math.floor(this.#buckets.length * HashMap.#SCALE));\n      this.#entriesCount = 0;\n      entries.forEach(([key, value]) => this.set(key, value));\n    }\n  }\n\n  set(...args) {\n    if (args.length < 2) {\n      throw TypeError('The \"set\" method expects 2 arguments: .set(key, value)');\n    }\n    const keyValueObject = {\n      key: args[0],\n      value: args[1],\n    };\n    const hash = this.#hash(\n      HashMap.#getStringKeyAndValidate(keyValueObject.key),\n    );\n    const bucketLinkedList = this.#getBucket(hash);\n    if (bucketLinkedList === undefined) {\n      // Create new bucket linked-list\n      const newLinkedList = new LinkedList();\n      newLinkedList.append(keyValueObject);\n      this.#setBucket(hash, newLinkedList);\n    } else {\n      // If the key exist, then update, else add\n      const node = HashMap.#findNode(bucketLinkedList, keyValueObject.key);\n      if (node === null) {\n        bucketLinkedList.append(keyValueObject);\n      } else {\n        node.value = keyValueObject;\n      }\n    }\n    this.#entriesCount++;\n    this.#scaleUpIfNeeded(); // Scale up if entries more than buckets\n    return this;\n  }\n\n  get(...args) {\n    if (args.length < 1) {\n      throw TypeError('The \"get\" method expects 1 argument: .get(key)');\n    }\n    const key = args[0];\n    const hash = this.#hash(HashMap.#getStringKeyAndValidate(key));\n    const bucketLinkedList = this.#getBucket(hash);\n    if (bucketLinkedList !== undefined) {\n      const node = HashMap.#findNode(bucketLinkedList, key);\n      if (node !== null) return node.value.value;\n    }\n    return null;\n  }\n\n  has(...args) {\n    if (args.length < 1) {\n      throw TypeError('The \"has\" method expect 1 argument: .has(key)');\n    }\n    const key = args[0];\n    const hash = this.#hash(HashMap.#getStringKeyAndValidate(key));\n    const bucketLinkedList = this.#getBucket(hash);\n    if (bucketLinkedList !== undefined) {\n      return HashMap.#findNode(bucketLinkedList, key) !== null;\n    }\n    return false;\n  }\n\n  remove(...args) {\n    if (args.length < 1) {\n      throw TypeError('The \"remove\" method expect 1 argument: .remove(key)');\n    }\n    const key = args[0];\n    const hash = this.#hash(HashMap.#getStringKeyAndValidate(key));\n    const bucketLinkedList = this.#getBucket(hash);\n    if (bucketLinkedList !== undefined) {\n      const node = HashMap.#findNode(bucketLinkedList, key);\n      if (!node) return false;\n      bucketLinkedList.removeAt(bucketLinkedList.find(node.value));\n      if (bucketLinkedList.length === 0) this.#setBucket(hash, undefined);\n      this.#entriesCount--;\n      return true;\n    }\n    return false;\n  }\n\n  clear(...args) {\n    if (args.length > 0) {\n      throw TypeError('The \"clear\" method expect ZERO (0) arguments: .clear()');\n    }\n    this.#buckets.forEach((bucket, i) => this.#setBucket(i, undefined));\n    this.#entriesCount = 0;\n  }\n\n  #getKeysOrValuesOrEntries(type = 'entries') {\n    type = type.toLocaleLowerCase();\n    const result = [];\n    this.#buckets.forEach((bucketLinkedList) => {\n      if (bucketLinkedList) {\n        bucketLinkedList.forEach((nodeValue) => {\n          switch (type) {\n            case 'keys':\n              result.push(nodeValue.key);\n              break;\n            case 'values':\n              result.push(nodeValue.value);\n              break;\n            default:\n              result.push([nodeValue.key, nodeValue.value]);\n          }\n        });\n      }\n    });\n    return result;\n  }\n\n  keys(...args) {\n    if (args.length > 0) {\n      throw TypeError('The \"keys\" method expect ZERO (0) arguments: .keys()');\n    }\n    return this.#getKeysOrValuesOrEntries('keys');\n  }\n\n  values(...args) {\n    if (args.length > 0) {\n      throw TypeError(\n        'The \"values\" method expect ZERO (0) arguments: .values()',\n      );\n    }\n    return this.#getKeysOrValuesOrEntries('values');\n  }\n\n  entries(...args) {\n    if (args.length > 0) {\n      throw TypeError(\n        'The \"entries\" method expect ZERO (0) arguments: .entries()',\n      );\n    }\n    return this.#getKeysOrValuesOrEntries('entries');\n  }\n}\n\n// I think we need to obey Open-Closed principle which broken by the immutability of JS prototypes/objects\nObject.freeze(Object.getPrototypeOf(HashMap)); // Freeze the prototype of class members\nObject.freeze(HashMap.prototype); // Freeze the instantiation prototype\nObject.freeze(HashMap); // Freeze the class members\n\nexport { HashMap };\n","import './index.css';\nimport HashMap from './hashmap';\n\nwindow.HashMap = HashMap;\n"],"names":["Node","node","value","arguments","length","undefined","next","prev","Object","defineProperties","nextNode","get","set","Error","configurable","enumerable","previousNode","nodeParent","checkType","v","TypeError","setNext","newNext","writable","setPrev","newPrev","setPrototypeOf","prototype","freeze","seal","getCircularReplacer","ancestors","key","_typeof","String","at","this","pop","includes","push","isDeeplyEqual","first","second","JSON","stringify","is","_head","WeakMap","_tail","_size","LinkedList","_this","_classCallCheck","_classPrivateFieldInitSpec","_len","values","Array","_key","forEach","append","_classPrivateFieldGet","_this2","_len2","_key2","_this$size","_classPrivateFieldSet","i","_this$size3","index","Number","isInteger","Math","abs","_this$size5","removedNode","_this$size7","result","concat","prepend","_this$size9","nodeAfterHead","nodeBeforeTail","toBePreviousNode","toBeNextNode","_this$size11","func","newList","passed","getPrototypeOf","_buckets","_entriesCount","_getBucket","WeakSet","_setBucket","_hash","_scaleUpIfNeeded","_getKeysOrValuesOrEntries","HashMap","_classPrivateMethodInitSpec","_this$entriesCount","keyValueObject","hash","_classPrivateMethodGet","_hash2","call","_classStaticPrivateMethodGet","_getStringKeyAndValidate","bucketLinkedList","_getBucket2","newLinkedList","_setBucket2","_findNode","_scaleUpIfNeeded2","_this$entriesCount3","removeAt","find","bucket","_getKeysOrValuesOrEntries2","_classStaticPrivateFieldSpecGet","_FACTOR","_SCALE","head","nodeListValue","charCodeAt","entries","floor","_ref","_ref2","type","toLocaleLowerCase","nodeValue","_HashMap","window"],"sourceRoot":""}