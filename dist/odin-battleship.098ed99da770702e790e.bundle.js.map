{"version":3,"file":"odin-battleship.098ed99da770702e790e.bundle.js","mappings":"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","sources":["webpack://top-javascript-study/./odin-battleship/helpers/create-element.js","webpack://top-javascript-study/./odin-battleship/game-events/game-events.js","webpack://top-javascript-study/./odin-battleship/ship/ship.js","webpack://top-javascript-study/./odin-battleship/game-board/game-board.js","webpack://top-javascript-study/./odin-battleship/player/player.js","webpack://top-javascript-study/./odin-battleship/components/board/index.js","webpack://top-javascript-study/./odin-battleship/helpers/create-game.js","webpack://top-javascript-study/./odin-battleship/components/player-info/index.js","webpack://top-javascript-study/./odin-battleship/helpers/capitalize.js","webpack://top-javascript-study/./odin-battleship/index.js"],"sourcesContent":["/**\n * Creates HTMLElement of the given 'tagName' with any of the given\n * className, id or attributes\n * @param {string} tagName\n * @param {string?} className\n * @param {string?} textContent\n * @param {Array<string, string>?} attrs\n * - Any number of attributes (each of which as a key-value pair)\n * @returns {HTMLElement}\n */\nexport default function createElement(\n  tagName,\n  className,\n  textContent,\n  ...attrs\n) {\n  if (typeof tagName !== 'string') {\n    throw TypeError(\"Missing 'tagName' of type 'string'!\");\n  }\n  const element = document.createElement(tagName);\n  if (className) element.className = className;\n  if (textContent) element.textContent = textContent;\n  // Flatten attrs 1 level depth (in case attrs is in the form of an Array of paris)\n  if (\n    attrs.length === 1 &&\n    Array.isArray(attrs[0]) &&\n    Array.isArray(attrs[0][0])\n  ) {\n    attrs = attrs.flat(1);\n  }\n  if (attrs.length > 0) {\n    for (let i = 0; i < attrs.length; i++) {\n      if (\n        Array.isArray(attrs[i]) &&\n        attrs[i].length === 2 &&\n        attrs[i][0] &&\n        typeof attrs[i][0] === 'string'\n      ) {\n        if (attrs[i][1] || attrs[i][1] === 0 || attrs[i][1] === '') {\n          element.setAttribute(attrs[i][0], attrs[i][1]);\n        }\n      } else {\n        throw TypeError(\n          \"A given attribute in '...attrs' must be in the form of [string, string]\",\n        );\n      }\n    }\n  }\n  return element;\n}\n\nexport { createElement };\n","const REGISTRY = {};\n\n/**\n * Adds the given callback/s to registered callbacks on the given event (eventName).\n * @param {string} eventName\n * @param  {...function} callbacks\n */\nfunction add(eventName, ...callbacks) {\n  if (\n    typeof eventName !== 'string' ||\n    !callbacks.every((c) => typeof c === 'function')\n  ) {\n    const strArgs = `${eventName}${callbacks.length > 0 ? ', ' + callbacks.toString().replace(/(?:\\[|\\])/, '') : ''}`;\n    throw TypeError(\n      `Expect event name of type 'string' and at least 1 callback! Given: '${strArgs}'`,\n    );\n  }\n\n  if (REGISTRY[eventName]) {\n    REGISTRY[eventName].push(...callbacks);\n  } else {\n    REGISTRY[eventName] = callbacks;\n  }\n}\nObject.freeze(add);\nObject.freeze(add.prototype);\n\n/**\n * Removes the given callback from the registered callbacks on the given event (eventName).\n *\n * NOTE: The given callback MUST be the same reference that you had gavin to 'add' in order to be removed.\n * @param {string} eventName\n * @param {function} callback\n */\nfunction remove(eventName, callback) {\n  if (typeof eventName !== 'string' || typeof callback !== 'function') {\n    throw TypeError(\n      `Expect (eventName: string) & (callback: function)! Given: '${eventName}, ${callback}'`,\n    );\n  }\n\n  if (REGISTRY[eventName]) {\n    REGISTRY[eventName] = REGISTRY[eventName].filter(\n      (registeredCallback) => registeredCallback !== callback,\n    );\n  }\n}\nObject.freeze(remove);\nObject.freeze(remove.prototype);\n\n/**\n * Emits the given event (eventName); All registered callbacks on that event gets called.\n * @param {string} eventName\n * @param  {...any} args\n */\nfunction emit(eventName, ...args) {\n  if (typeof eventName !== 'string') {\n    throw TypeError(\n      `Expect at least 1 argument of type 'string'! Given: '${eventName}'`,\n    );\n  }\n\n  if (REGISTRY[eventName]) {\n    REGISTRY[eventName].forEach((callback) => {\n      callback(...args);\n    });\n  }\n}\nObject.freeze(emit);\nObject.freeze(emit.prototype);\n\nconst gameEvents = {\n  ATTACK: 'Fire',\n  HIT: 'Boom',\n  MISS: 'Oops',\n  LOSS: 'Meh',\n  GAME_OVER: 'Bye',\n  SHIP_MOVED: 'Voo',\n  SHIP_ROTATED: 'Woo',\n  SHIP_SELECTED: 'Tick',\n  SHIP_IS_SUNK: 'whoa',\n  add,\n  remove,\n  emit,\n};\nObject.freeze(gameEvents);\n\nexport default gameEvents;\nexport { gameEvents };\n","export default function Ship(length) {\n  if (!Number.isInteger(length) || length < 2 || length > 5) {\n    throw TypeError(\n      `Expect 1 argument (length) of type 'number'; 1 < length < 6! given '${length}'`,\n    );\n  }\n\n  // Ship's state & logic\n  let hits = 0,\n    sunk = false;\n  const hit = () => {\n    if (!sunk) {\n      hits++;\n      sunk = hits >= length;\n    }\n  };\n  const isSunk = () => sunk;\n\n  // Create Ship object with its members to be recorded (just for autocompletion) before making them non-writable\n  const ship = {\n    length,\n    hits,\n    hit,\n    isSunk,\n  };\n\n  // Set the prototype of ship object to Ship.prototype\n  Object.setPrototypeOf(ship, Ship.prototype);\n\n  // Reconfigure all Ship's members and make them non-writable\n  const config = { configurable: false, enumerable: true };\n  const configExt = { ...config, writable: false };\n  Object.defineProperties(ship, {\n    // Set the constructor of a ship object to Ship\n    constructor: {\n      ...configExt,\n      enumerable: false,\n      value: Ship,\n    },\n    length: {\n      ...config,\n      get() {\n        return length;\n      },\n    },\n    hits: {\n      ...config,\n      get() {\n        return hits;\n      },\n    },\n    hit: {\n      ...configExt,\n      value: hit,\n    },\n    isSunk: {\n      ...configExt,\n      value: isSunk,\n    },\n  });\n\n  return ship;\n}\n\nexport { Ship };\n","import { gameEvents } from '../game-events';\nimport { Ship } from '../ship';\n\n// Save the custom board setup in order to reach out its values between UI renders\nconst oldBoardSetup = [];\nconst oldShips = [];\n\n/**\n * Creates the battleship's player's logical game board\n * @param {boolean} computerBoard - If true, always returns randomized board\n * @returns @type {Object}\n */\nexport default function GameBoard(computerBoard) {\n  const BOARD_SIDE_LENGTH = 10;\n\n  // Create the board & Fill it with cell objects\n  const board = [];\n  for (let i = 0; i < BOARD_SIDE_LENGTH; i++) {\n    board[i] = [];\n    for (let j = 0; j < BOARD_SIDE_LENGTH; j++) {\n      board[i][j] = {\n        ship: null,\n        attacked: false,\n        missed: false,\n      };\n    }\n  }\n\n  const shipsAreas = [];\n\n  // Define a private helper that takes 'n' to generate random number 'r': 0 < r < n\n  const getRandomUpToButNotIncluding = (n) => Math.floor(Math.random() * n);\n\n  // Define a private helper to check whether a cell on board is empty\n  const isEmptyCell = ([i, j]) => board[i][j].ship === null;\n\n  // Define a private helper to create a list of empty cells that constitutes a valid ship area\n  const getValidShipArea = (ship, firstCellPlace, direction) => {\n    const result = [];\n    const currentCellPlace = firstCellPlace;\n    for (let i = 0; i < ship.length; i++) {\n      if (!isEmptyCell(currentCellPlace)) {\n        return [];\n      }\n      // Push a copy of it on the 'result' array (ship area)\n      result.push([...currentCellPlace]);\n      // Move forward the current cell's place in the given direction\n      currentCellPlace[direction]++;\n      /* NOTE: I am PUSHING a COPY of the 'currentCellPlace', because I am MUTATING its values when I MOVE it */\n    }\n    return result;\n  };\n\n  // Create a flag indicates to a randomization fail (IN CASE OF LONG/INFINITE LOOP)\n  let randomizationFailed = false;\n\n  // Define a private helper to insert a given ship into a random place in the board\n  const insertShipInRandomBoardPlace = (ship) => {\n    let shipArea = []; // Placeholder for cells' places of the ship\n    let loopsCount = 0;\n    while (shipArea.length === 0 && loopsCount < 100) {\n      loopsCount++;\n      // Choose a random direction\n      const movingAxis = getRandomUpToButNotIncluding(2);\n      const fixedAxis = movingAxis === 0 ? 1 : 0;\n      // Choose random cell place for the first cell\n      const randomCellPlace = Array(2);\n      // Get random number 'r' for moving axis, r: 0 > r > (board-side's length - ship's length)\n      randomCellPlace[movingAxis] = getRandomUpToButNotIncluding(\n        BOARD_SIDE_LENGTH - ship.length,\n      );\n      // Get random number 'r' for fixed axis, r: 0 > r > (board-side's length)\n      randomCellPlace[fixedAxis] =\n        getRandomUpToButNotIncluding(BOARD_SIDE_LENGTH);\n      shipArea = getValidShipArea(ship, randomCellPlace, movingAxis);\n    }\n    randomizationFailed = loopsCount >= 100;\n    shipArea.forEach(([i, j]) => {\n      board[i][j].ship = ship;\n    });\n    // Save ship's area\n    shipsAreas.push([...shipArea]);\n  };\n\n  // Insert the ships in random places\n  const ships = [Ship(2), Ship(3), Ship(3), Ship(4), Ship(5)];\n  // If there is an old board setup use it otherwise, setup the new board\n  if (\n    !computerBoard &&\n    Array.isArray(oldBoardSetup) &&\n    oldBoardSetup.length === BOARD_SIDE_LENGTH\n  ) {\n    // Setup the board as it was\n    ships.splice(0, ships.length, ...oldShips);\n    board.forEach((row, i) => {\n      row.forEach((cell, j) => {\n        cell.ship = oldBoardSetup[i][j].ship;\n        if (cell.ship) {\n          const shipIndex = ships.findIndex((ship) => ship === cell.ship);\n          if (!Array.isArray(shipsAreas[shipIndex])) {\n            shipsAreas[shipIndex] = [];\n          }\n          shipsAreas[shipIndex].push([i, j]);\n        }\n      });\n    });\n    // Reset the ships' state\n    shipsAreas.forEach((shipArea, shipIndex) => {\n      const oldShip = board[shipArea[0][0]][shipArea[0][1]].ship;\n      const newShip = Ship(oldShip.length);\n      ships[shipIndex] = newShip;\n      shipArea.forEach(([i, j]) => {\n        board[i][j].ship = ships[shipIndex];\n      });\n    });\n  } else {\n    do {\n      ships.forEach(insertShipInRandomBoardPlace);\n    } while (randomizationFailed);\n  }\n\n  // Define helper function to check whether a cell is inside the board's boundaries\n  const isCellOnBoard = ([i, j]) => {\n    return i >= 0 && j >= 0 && i < BOARD_SIDE_LENGTH && j < BOARD_SIDE_LENGTH;\n  };\n\n  /**\n   * Attacks a cell on the board and emits HIT, MISS, or LOSS depending on the state of this ship's part.\n   * Nothing happens if the given cell is already attacked or already missed.\n   * @param {[number, number]} cellPair - A pair of number represents a cell on the board\n   */\n  const receiveAttack = ([i, j]) => {\n    const last = [BOARD_SIDE_LENGTH - 1, BOARD_SIDE_LENGTH - 1];\n    if (!isCellOnBoard([i, j])) {\n      throw TypeError(\n        `Invalid coordinates! It should be in the range from [0,0] to ${last}, the given is ${[i, j]}.`,\n      );\n    }\n    const cell = board[i][j];\n    if (cell.ship && !cell.attacked) {\n      cell.ship.hit();\n      cell.attacked = true;\n      gameEvents.emit(gameEvents.HIT, [i, j]);\n      if (cell.ship.isSunk()) {\n        gameEvents.emit(\n          gameEvents.SHIP_IS_SUNK,\n          shipsAreas[ships.indexOf(cell.ship)],\n        );\n      }\n    } else if (!cell.ship && !cell.missed) {\n      cell.missed = true;\n      gameEvents.emit(gameEvents.MISS, [i, j]);\n    }\n    if (ships.every((ship) => ship.isSunk())) {\n      gameEvents.emit(gameEvents.LOSS);\n    }\n  };\n\n  // Define a private helper to cache a user customized board\n  const cacheCustomBoard = () => {\n    for (let i = 0; i < BOARD_SIDE_LENGTH; i++) {\n      oldBoardSetup[i] = [];\n      for (let j = 0; j < BOARD_SIDE_LENGTH; j++) {\n        oldBoardSetup[i][j] = {\n          ship: board[i][j].ship,\n          attacked: board[i][j].attacked,\n          missed: board[i][j].missed,\n        };\n      }\n    }\n  };\n\n  // Define a private helper to cache current ships state\n  const cacheShips = () => oldShips.splice(0, oldShips.length, ...ships);\n\n  // Define a private helper to reset the state of the board\n  const resetBoard = () => {\n    board.forEach((cell) => {\n      cell.attacked = false;\n      cell.missed = false;\n    });\n  };\n\n  // Define a private helper to fill the ship's new area\n  const moveShipAreaOnBoard = (shipAreaIndex, newAreaToOccupy) => {\n    shipsAreas[shipAreaIndex] = newAreaToOccupy;\n    shipsAreas[shipAreaIndex].forEach(([i, j]) => {\n      const cell = board[i][j];\n      cell.ship = ships[shipAreaIndex];\n    });\n  };\n\n  // Define a private helper to empty the ship's old area\n  const emptyShipAreaOnBoard = (shipAreaToEmpty) => {\n    shipAreaToEmpty.forEach(([i, j]) => {\n      const cell = board[i][j];\n      cell.ship = null;\n    });\n  };\n\n  // Define helper checks whether a cell is occupied by any shipArea other than the area on a given index\n  const isValidMove = (shipAreaIndex, cellToOccupy) => {\n    const otherShipsAreas = shipsAreas.filter((_, i) => i !== shipAreaIndex);\n    return (\n      isCellOnBoard(cellToOccupy) &&\n      !otherShipsAreas.some((shipArea) =>\n        shipArea.some((cell) => `${cell}` === `${cellToOccupy}`),\n      )\n    );\n  };\n\n  const moveShip = (shipAreaIndex, [deltaI, deltaJ]) => {\n    if (shipAreaIndex >= shipsAreas.length) {\n      throw TypeError(\n        `Invalid ship index! Ships count = ${shipsAreas.length}. Given index = ${shipAreaIndex}.`,\n      );\n    }\n    // Make sure that the new area is valid before moving to it\n    const areaToOccupy = [];\n    const usedShipArea = shipsAreas[shipAreaIndex];\n    for (let i = 0; i < usedShipArea.length; i++) {\n      const cellToOccupy = [\n        usedShipArea[i][0] + deltaI,\n        usedShipArea[i][1] + deltaJ,\n      ];\n      if (!isValidMove(shipAreaIndex, cellToOccupy)) {\n        return false;\n      }\n      areaToOccupy.push(cellToOccupy);\n    }\n    emptyShipAreaOnBoard(usedShipArea);\n    moveShipAreaOnBoard(shipAreaIndex, areaToOccupy);\n    resetBoard();\n    cacheCustomBoard();\n    cacheShips();\n    gameEvents.emit(gameEvents.SHIP_MOVED);\n    return true;\n  };\n\n  // Create gameBoard object\n  const gameBoard = {\n    board,\n    ships,\n    shipsAreas,\n    /**\n     * Attacks a cell on the board and emits HIT, MISS, or LOSS depending on the state of this ship's part.\n     * Nothing happens if the given cell is already attacked or already missed.\n     * @param {[number, number]} cellPair - A pair of number represents a cell on the board\n     */\n    receiveAttack,\n    /**\n     * Returns true if the ship moved up (and emits SHIP_MOVED event), Otherwise, returns false.\n     * @param {number} shipIndex - The index (on ships array or shipsAreas) of a ship to move\n     * @returns {boolean}\n     */\n    moveShipUp(shipIndex) {\n      return moveShip(shipIndex, [-1, 0]);\n    },\n    /**\n     * Returns true if the ship moved down (and emits SHIP_MOVED event), Otherwise returns false.\n     * @param {number} shipIndex - The index (on ships array or shipsAreas) of a ship to move\n     * @returns {boolean}\n     */\n    moveShipDown(shipIndex) {\n      return moveShip(shipIndex, [1, 0]);\n    },\n    /**\n     * Returns true if the ship moved left (and emits SHIP_MOVED event), Otherwise returns false.\n     * @param {number} shipIndex - The index (on ships array or shipsAreas) of a ship to move\n     * @returns {boolean}\n     */\n    moveShipLeft(shipIndex) {\n      return moveShip(shipIndex, [0, -1]);\n    },\n    /**\n     * Returns true if the ship moved right (and emits SHIP_MOVED event), Otherwise returns false.\n     * @param {number} shipIndex - The index (on ships array or shipsAreas) of a ship to move\n     * @returns {boolean}\n     */\n    moveShipRight(shipIndex) {\n      return moveShip(shipIndex, [0, 1]);\n    },\n    /**\n     * Moves the ship from its area to any valid (empty) area on the board.\n     * Returns true if the ship moved (and emit SHIP_MOVED event), Otherwise returns false.\n     * @param {[number, number]} occupiedCellPair - Part of the ship that will move\n     * @param {[number, number]} cellPairToOccupy - Part of the empty area to move the ship to it\n     * @returns {boolean}\n     */\n    moveShip(occupiedCellPair, cellPairToOccupy) {\n      // Assert that every given argument is a pair\n      if (\n        !Array.isArray(occupiedCellPair) ||\n        !Array.isArray(cellPairToOccupy) ||\n        occupiedCellPair.length !== 2 ||\n        cellPairToOccupy.length !== 2\n      ) {\n        throw TypeError(\n          `Invalid arguments! Expect 2 pairs, given: ${occupiedCellPair}, ${cellPairToOccupy}`,\n        );\n      }\n      // Return false if both arguments are equal\n      if (`${occupiedCellPair}` === `${cellPairToOccupy}`) return false;\n      // Assert that every cell is on board\n      if (\n        !isCellOnBoard(occupiedCellPair) ||\n        !isCellOnBoard(cellPairToOccupy)\n      ) {\n        throw TypeError(\n          `Given an out of board's boundary cell! Board sides are from 0 to ${BOARD_SIDE_LENGTH - 1}`,\n        );\n      }\n      const [occupiedI, occupiedJ] = occupiedCellPair;\n      const [toOccupyI, toOccupyJ] = cellPairToOccupy;\n      const cellToOccupy = board[toOccupyI][toOccupyJ];\n      const occupiedCell = board[occupiedI][occupiedJ];\n      // If the given cell to drop onto has other ship return false\n      if (cellToOccupy.ship && cellToOccupy.ship !== occupiedCell.ship) {\n        return false;\n      }\n      // Try to move and if all new Area are valid & empty commit the move\n      const shipAreaIndex = shipsAreas.findIndex((shipArea) => {\n        return shipArea.some(\n          (cellPair) => `${cellPair}` === `${occupiedCellPair}`,\n        );\n      });\n      if (shipAreaIndex < 0) return false;\n      const deltaIAndDeltaJ = [toOccupyI - occupiedI, toOccupyJ - occupiedJ];\n      return moveShip(shipAreaIndex, deltaIAndDeltaJ);\n    },\n    /**\n     * Returns true if the ship is rotated (and emits SHIP_ROTATED event), Otherwise returns false\n     * @param {number} shipIndex - The index (on ships array or shipsAreas) of a ship to rotate\n     * @returns {boolean}\n     */\n    rotateShip(shipIndex) {\n      if (\n        !Number.isInteger(shipIndex) ||\n        shipIndex < 0 ||\n        shipIndex >= shipsAreas.length\n      ) {\n        throw TypeError(\n          `Invalid ship index! Should be a number from 0 to ${shipsAreas.length}, given: ${shipIndex}`,\n        );\n      }\n      const usedShipArea = shipsAreas[shipIndex];\n      if (usedShipArea.length <= 1) return false;\n      const midIndex = Math.floor(usedShipArea.length / 2);\n      const verticalShip = usedShipArea[1][0] > usedShipArea[0][0];\n      const rotatedShipArea = [];\n      for (let i = 0; i < usedShipArea.length; i++) {\n        if (midIndex === i) rotatedShipArea.push(usedShipArea[i]);\n        else {\n          const [midPairConstSide, midPairVarSide] = verticalShip\n            ? [usedShipArea[midIndex][0], usedShipArea[midIndex][1]]\n            : [usedShipArea[midIndex][1], usedShipArea[midIndex][0]];\n          const occupiedCellPair = [midPairConstSide];\n          const deltaCurrentIdex = Math.abs(midIndex - i);\n          const beforeMidPair = i < midIndex;\n          const otherSide = beforeMidPair\n            ? midPairVarSide - deltaCurrentIdex\n            : midPairVarSide + deltaCurrentIdex;\n          if (verticalShip) {\n            occupiedCellPair.push(otherSide);\n          } else {\n            occupiedCellPair.unshift(otherSide);\n          }\n          if (!isValidMove(shipIndex, occupiedCellPair)) return false;\n          rotatedShipArea.push(occupiedCellPair);\n        }\n      }\n      emptyShipAreaOnBoard(usedShipArea);\n      moveShipAreaOnBoard(shipIndex, rotatedShipArea);\n      resetBoard();\n      cacheCustomBoard();\n      cacheShips();\n      gameEvents.emit(gameEvents.SHIP_ROTATED);\n      return true;\n    },\n  };\n\n  // Make a gameBoard object an instance of GameBoard\n  Object.setPrototypeOf(gameBoard, GameBoard.prototype);\n  Object.defineProperty(gameBoard, 'constructor', {\n    value: GameBoard,\n    writable: false,\n    configurable: false,\n    enumerable: false,\n  });\n\n  // Make a gameBoard object immutable\n  Object.freeze(gameBoard);\n\n  return gameBoard;\n}\n\nexport { GameBoard };\n","import { gameEvents } from '../game-events';\nimport { GameBoard } from '../game-board';\n\n/**\n * A factory creates player object. A call without argument creates player of type 'computer'.\n * @param {string?} type - The type of the returned player ['computer' | 'human']\n * @returns {Player}\n */\nexport default function Player(playerType) {\n  // Assert that the given type is valid type or it is 'undefined', Otherwise, throw error\n  if (\n    playerType !== undefined &&\n    playerType !== Player.TYPES.COMPUTER &&\n    playerType !== Player.TYPES.HUMAN\n  ) {\n    throw TypeError(\n      `Invalid type! Only '${Player.TYPES.COMPUTER}' & '${Player.TYPES.HUMAN}' are the valid types. Given: '${playerType}'`,\n    );\n  }\n\n  const type = playerType === undefined ? Player.TYPES.COMPUTER : playerType;\n  const gameBoard = GameBoard(type === Player.TYPES.COMPUTER);\n\n  const player = {\n    type,\n    gameBoard,\n  };\n\n  // Add play method to player type 'computer'\n  if (player.type === Player.TYPES.COMPUTER) {\n    const maxHeight = player.gameBoard.board.length;\n    const maxWidth = player.gameBoard.board[0]?.length ?? 0;\n    // Create empty board to illustrate the opponent's board on top of it\n    const opponentBoard = [];\n    for (let i = 0; i < maxHeight; i++) {\n      opponentBoard[i] = [];\n      for (let j = 0; j < maxWidth; j++) {\n        opponentBoard[i][j] = {\n          attacked: false,\n          missed: false,\n        };\n      }\n    }\n    // Create an array to hold the opponent's sunk ships' areas\n    const opponentSunkShipsAreas = [];\n    // Create an array to hold high priority places to be targeted, if don't have smart target\n    const highPriorityTargetsQ = [];\n    // Create an array to hold medium priority places to be targeted, if don't have high priority targets\n    const mediumPriorityTargetsQ = [];\n    // Save the targeted cell\n    let target = null;\n    // Save all valid targets\n    const validTargets = [];\n    opponentBoard.forEach((row, i) => {\n      row.forEach((cell, j) => {\n        if (!cell.attacked && !cell.missed) validTargets.push([i, j]);\n      });\n    });\n    // Create a variable to hold our direction\n    // If it was a successful direction, then we keep moving in that direction\n    // Otherwise, reset the direction to null again\n    let previousDirection = null;\n    // Create a variable to hold a smart target instead of a random one\n    // The smart target is any adjacent cell and could be in a successful direction\n    let smartTarget = null;\n    // Create a helper checks whether a given cell is valid target\n    const isValidTarget = ([i, j]) => {\n      const opponentCell = opponentBoard[i]?.[j];\n      return opponentCell && !opponentCell.attacked && !opponentCell.missed;\n    };\n    // Create helper that remove a given target form high/medium priority if exist.\n    const removeFromPrioritizedAndValidTargets = ([i, j]) => {\n      const isEqualToGivenTarget = ([savedI, savedJ]) =>\n        savedI === i && savedJ === j;\n      const highPriorityIndex =\n        highPriorityTargetsQ.findIndex(isEqualToGivenTarget);\n      if (highPriorityIndex > -1) {\n        highPriorityTargetsQ.splice(highPriorityIndex, 1);\n      }\n      const mediumPriorityIndex =\n        mediumPriorityTargetsQ.findIndex(isEqualToGivenTarget);\n      if (mediumPriorityIndex > -1) {\n        mediumPriorityTargetsQ.splice(mediumPriorityIndex, 1);\n      }\n      const validTargetIndex = validTargets.findIndex(isEqualToGivenTarget);\n      if (validTargetIndex > -1) {\n        validTargets.splice(validTargetIndex, 1);\n      }\n    };\n    // Create a helper that gets all possible cells to attack (based on the last attacked cell)\n    const setSmartTarget = () => {\n      const DIRECTIONS = [\n        [-1, 0],\n        [0, 1],\n        [1, 0],\n        [0, -1],\n      ];\n      // Separate the direction index from the cell, because we need to keep track the direction itself to follow again\n      const validAdjacentCellsOrNulls = [];\n      // Save the indexes of the valid directions\n      const validAdjacentCellsIndexes = [];\n      DIRECTIONS.forEach((dirMod, i) => {\n        const adjacentCellPair = [target[0] + dirMod[0], target[1] + dirMod[1]];\n        if (isValidTarget(adjacentCellPair)) {\n          validAdjacentCellsOrNulls.push(adjacentCellPair);\n          validAdjacentCellsIndexes.push(i);\n        } else {\n          validAdjacentCellsOrNulls.push(null);\n        }\n      });\n      if (validAdjacentCellsIndexes.length > 0) {\n        // If the previous direction is null or lead to valid adjacent cell,\n        // then set it to lead to a valid adjacent cell\n        if (\n          previousDirection === null ||\n          !validAdjacentCellsIndexes.includes(previousDirection)\n        ) {\n          previousDirection =\n            validAdjacentCellsIndexes[\n              Math.floor(Math.random() * validAdjacentCellsIndexes.length)\n            ];\n        }\n        // Follow the previous direction\n        smartTarget = validAdjacentCellsOrNulls[previousDirection];\n      } else {\n        // There is not valid adjacent cells\n        previousDirection = null;\n        smartTarget = null;\n      }\n    };\n    // define a private helper to check if a give cell is part of a sunk ship\n    const isPartOfSunkShip = ([i, j]) => {\n      return opponentSunkShipsAreas.some((shipArea) => {\n        return shipArea.some(([sunkI, sunkJ]) => sunkI === i && sunkJ === j);\n      });\n    };\n    /*\n     * define a private helper does the following:\n     * - Look for EVERY cell that: not attacked, not missed,\n     *   and has on both sides attacked cells not included in opponent's sunk ships array.\n     * - Save these cells in an array of cells that has the highest shooting priority.\n     * - Save the medium priority cells which are the cells around attacked cells.\n     */\n    const updateMediumAndHighPriorityTargets = () => {\n      const DIRS_KEYS = ['LEFT', 'RIGHT', 'TOP', 'BOTTOM'];\n      const DIR_MOD = {\n        [DIRS_KEYS[0]]: [0, -1],\n        [DIRS_KEYS[1]]: [0, 1],\n        [DIRS_KEYS[2]]: [-1, 0],\n        [DIRS_KEYS[3]]: [1, 0],\n      };\n      const axisModifiers = [\n        [DIR_MOD.TOP, DIR_MOD.BOTTOM],\n        [DIR_MOD.LEFT, DIR_MOD.RIGHT],\n      ];\n      opponentBoard.forEach((row, i) => {\n        row.forEach((cell, j) => {\n          if (!cell.attacked && !cell.missed) {\n            // Search for high priority targets\n            for (let k = 0; k < axisModifiers.length; k++) {\n              const firstCI = i + axisModifiers[k][0][0];\n              const firstCJ = j + axisModifiers[k][0][1];\n              const secondCI = i + axisModifiers[k][1][0];\n              const secondCJ = j + axisModifiers[k][1][1];\n              if (\n                !isPartOfSunkShip([firstCI, firstCJ]) &&\n                !isPartOfSunkShip([secondCI, secondCJ])\n              ) {\n                const firstC = opponentBoard[firstCI]?.[firstCJ];\n                const secondC = opponentBoard[secondCI]?.[secondCJ];\n                if (firstC && secondC && firstC.attacked && secondC.attacked) {\n                  highPriorityTargetsQ.push([i, j]);\n                }\n              }\n            }\n          } else if (cell.attacked && !isPartOfSunkShip([i, j])) {\n            // Search for medium priority targets\n            for (let k = 0; k < DIRS_KEYS.length; k++) {\n              const modifier = DIR_MOD[DIRS_KEYS[k]];\n              const newI = i + modifier[0];\n              const newJ = j + modifier[1];\n              const adjacentC = opponentBoard[newI]?.[newJ];\n              if (adjacentC && !adjacentC.missed && !adjacentC.attacked) {\n                const isExist = ([oldI, oldJ]) =>\n                  oldI === newI && oldJ === newJ;\n                if (\n                  highPriorityTargetsQ.findIndex(isExist) < 0 &&\n                  mediumPriorityTargetsQ.findIndex(isExist) < 0\n                ) {\n                  mediumPriorityTargetsQ.push([newI, newJ]);\n                }\n              }\n            }\n          }\n        });\n      });\n    };\n    // Create a flag to distinguish our attacks\n    let attacked = false;\n    // Handle MISS event\n    gameEvents.add(gameEvents.MISS, () => {\n      if (attacked) {\n        const [i, j] = target;\n        opponentBoard[i][j].missed = true;\n        previousDirection = null;\n        attacked = false;\n        updateMediumAndHighPriorityTargets();\n        if (highPriorityTargetsQ.length > 0) {\n          smartTarget = highPriorityTargetsQ.shift();\n        } else if (mediumPriorityTargetsQ.length > 0) {\n          smartTarget = mediumPriorityTargetsQ.shift();\n        }\n      }\n    });\n    // Handle HIT events\n    gameEvents.add(gameEvents.HIT, () => {\n      if (attacked) {\n        const [i, j] = target;\n        opponentBoard[i][j].attacked = true;\n        setSmartTarget();\n        attacked = false;\n        mediumPriorityTargetsQ.splice(0);\n        highPriorityTargetsQ.splice(0);\n      }\n    });\n    // Handle SHIP_IS_SUNK to save all opponent's sunk ships' areas in an array\n    gameEvents.add(gameEvents.SHIP_IS_SUNK, (shipArea) => {\n      const sunkShipArea = [];\n      shipArea.forEach((shipCellPair) => sunkShipArea.push([...shipCellPair]));\n      opponentSunkShipsAreas.push(sunkShipArea);\n    });\n    player.play = () => {\n      if (validTargets.length > 0) {\n        if (!smartTarget) {\n          const randomTargetIndex = Math.floor(\n            Math.random() * validTargets.length,\n          );\n          target = validTargets[randomTargetIndex];\n        } else {\n          target = smartTarget;\n          smartTarget = null;\n        }\n        removeFromPrioritizedAndValidTargets(target);\n        attacked = true;\n        gameEvents.emit(gameEvents.ATTACK, target);\n      } else {\n        attacked = false;\n        gameEvents.emit(gameEvents.GAME_OVER);\n      }\n    };\n  }\n\n  // Make the player object an instance of 'Player'\n  Object.setPrototypeOf(player, Player.prototype);\n  // Set 'Player' as the constructor for the player object\n  Object.defineProperty(player, 'constructor', {\n    value: Player,\n    writable: false,\n    enumerable: false,\n    configurable: false,\n  });\n  Object.freeze(player);\n\n  return player;\n}\n\n// Add TYPES as a static property on 'Player'\nPlayer.TYPES = { COMPUTER: 'C', HUMAN: 'H' };\n\n// Freeze Player & its prototype\nObject.freeze(Player);\nObject.freeze(Player.prototype);\n\nexport { Player };\n","import './index.css';\n\nimport { createElement } from '../../helpers/create-element';\nimport { GameBoard } from '../../game-board';\nimport { gameEvents } from '../../game-events';\n\n// Save the held cell pair GLOBALLY to reach the previous value between renders\nlet heldCellPair = null;\nlet heldShipAreaIndex = -1;\n\n// Create a click counter to determine if a ship is double clicked\nlet pointerUpTwice = 0;\n\n/**\n * Creates a player's board UI component\n * @param {GameBoard} playerGameBoard - An instance of 'GameBoard'\n * @param {boolean} hidden - Hidden player's ships indicator\n * @param {boolean} disabled - If true, the returned board' UI will look disabled\n * @param {boolean} clickable - If true, the returned board won't listen to 'click' events\n * @returns {HTMLDivElement}\n */\nexport default function Board(\n  playerGameBoard,\n  hidden,\n  disabled,\n  clickable,\n  movable,\n) {\n  [playerGameBoard, hidden, disabled].forEach((arg) => {\n    if (arg === undefined) {\n      throw TypeError(\"'Board' is called with an invalid number of arguments!\");\n    }\n  });\n\n  if (!(playerGameBoard instanceof GameBoard)) {\n    throw TypeError(\n      `'Board' is called with invalid 'playerGameBoard'! Given '${playerGameBoard}'.`,\n    );\n  }\n\n  if (typeof hidden !== 'boolean' || typeof disabled !== 'boolean') {\n    throw TypeError(\n      `'Board' expects 'hidden' & 'disabled' of type 'boolean'! Given '${hidden} & ${disabled}'.`,\n    );\n  }\n\n  const board = createElement(\n    'div',\n    'board-container' + (disabled ? ' disabled' : ''),\n  );\n\n  let boardWidth = 0;\n\n  const findShipAreaIndex = (shipCellPair) =>\n    playerGameBoard.shipsAreas.findIndex((shipArea) =>\n      shipArea.some((cellPair) => `${cellPair}` === `${shipCellPair}`),\n    );\n\n  playerGameBoard.board.forEach((row, i) => {\n    boardWidth = row.length;\n    row.forEach((cell, j) => {\n      const cellShipAreaIndex = findShipAreaIndex([i, j]);\n      const held =\n        heldShipAreaIndex > -1 && heldShipAreaIndex === cellShipAreaIndex;\n      let className = 'board-cell';\n      if (cell.ship) {\n        if (!hidden) className += ' ship';\n        if (cell.ship.isSunk()) className += ' sunk';\n        if (movable) className += ' movable';\n        if (held) className += ' held';\n        else if (cell.attacked) className += ' attacked';\n      } else if (cell.missed) className += ' missed';\n      const boardCell = createElement('div', className);\n      // Click on a ship logic\n      if (clickable) {\n        boardCell.addEventListener('click', () => {\n          gameEvents.emit(gameEvents.ATTACK, [i, j]);\n        });\n      }\n      // Drag a ship logic\n      if (movable) {\n        const holdBoardCell = (event) => {\n          if (event.button === 0 || event.pointerType === 'touch') {\n            // Prevent default behaviors: drag & fire mouse event with pointer event\n            event.preventDefault();\n            // Announce that a ship is selected\n            if (cellShipAreaIndex > -1) {\n              gameEvents.emit(gameEvents.SHIP_SELECTED, cellShipAreaIndex);\n            }\n            heldCellPair = [i, j];\n            heldShipAreaIndex = findShipAreaIndex(heldCellPair);\n          }\n        };\n        const releaseHeldCell = () => {\n          heldCellPair = null;\n          heldShipAreaIndex = -1;\n          pointerUpTwice++;\n          if (pointerUpTwice === 2 && cellShipAreaIndex > -1) {\n            // Double click = rotate ;)\n            playerGameBoard.rotateShip(cellShipAreaIndex);\n            gameEvents.emit(gameEvents.SHIP_ROTATED);\n            pointerUpTwice = 0;\n          } else {\n            gameEvents.emit(gameEvents.SHIP_MOVED);\n            setTimeout(() => {\n              pointerUpTwice = 0;\n            }, 250);\n          }\n        };\n        const moveHeldShip = () => {\n          const pairToOccupy = [i, j];\n          if (heldCellPair && `${heldCellPair}` !== `${pairToOccupy}`) {\n            const moved = playerGameBoard.moveShip(heldCellPair, pairToOccupy);\n            if (moved) {\n              heldCellPair = pairToOccupy;\n              heldShipAreaIndex = findShipAreaIndex(heldCellPair);\n            }\n          }\n        };\n        if (\n          boardCell.onpointerdown !== undefined ||\n          window.navigator.maxTouchPoints > 0\n        ) {\n          // Prevent touchmove event because it intercepts the pointer events\n          boardCell.addEventListener('touchmove', (e) => e.preventDefault());\n          boardCell.addEventListener('gotpointercapture', (event) => {\n            try {\n              // https://developer.mozilla.org/en-US/docs/Web/API/Element/releasePointerCapture\n              event.target.releasePointerCapture(event.pointerId);\n            } catch (e) {\n              console.log(e.message);\n            }\n          });\n          boardCell.addEventListener('pointerdown', holdBoardCell);\n          boardCell.addEventListener('pointerenter', moveHeldShip, {\n            passive: true,\n          });\n          boardCell.addEventListener('pointerup', releaseHeldCell);\n          boardCell.addEventListener('pointercancel', releaseHeldCell);\n        } else {\n          boardCell.addEventListener('mousedown', holdBoardCell);\n          boardCell.addEventListener('mouseenter', moveHeldShip, {\n            passive: true,\n          });\n          boardCell.addEventListener('mouseup', releaseHeldCell);\n        }\n      }\n      board.appendChild(boardCell);\n    });\n  });\n\n  // Grid styles\n  board.style.display = 'grid';\n  board.style.gridTemplateColumns = `repeat(${boardWidth}, 1fr)`;\n  board.style.gridTemplateRows = `repeat(${boardWidth}, auto)`;\n\n  return board;\n}\n\nexport { Board };\n","import { createElement } from './create-element';\nimport { gameEvents } from '../game-events';\nimport { PlayerInfo } from '../components/player-info';\nimport { Board } from '../components/board';\nimport { Player } from '../player';\n\n/**\n * Creates a game object to hold the state of the game\n * @returns @type {Object}\n */\nfunction createNewState() {\n  return {\n    playersData: [\n      {\n        name: 'you',\n        player: Player(Player.TYPES.HUMAN),\n        playerUI: createElement('div', 'first-player'),\n      },\n      {\n        name: 'computer',\n        player: Player(Player.TYPES.COMPUTER),\n        playerUI: createElement('div', 'second-player'),\n      },\n    ],\n    currentPlayerIndex: 0,\n    allPlayersDisabled: false,\n    gameStarted: false,\n    /**\n     * Switches the current player's index\n     */\n    switchCurrentPlayer() {\n      this.currentPlayerIndex = (this.currentPlayerIndex + 1) % 2;\n    },\n    /**\n     * Renders the player's info section in the player's UI\n     * @param {number} playerIndex\n     */\n    renderPlayerInfo(playerIndex) {\n      const playerData = this.playersData[playerIndex];\n      const oldChildren = [...playerData.playerUI.children];\n      oldChildren.forEach((child) => child.remove());\n      playerData.playerUI.append(\n        PlayerInfo(\n          playerData.name,\n          playerData.player.type,\n          this.gameStarted || this.allPlayersDisabled\n            ? null\n            : playerData.player.gameBoard,\n        ),\n      );\n      if (oldChildren.length > 1) {\n        playerData.playerUI.appendChild(oldChildren[1]);\n      }\n    },\n    /**\n     * Renders the player's board section in the player's UI\n     * @param {number} playerIndex\n     */\n    renderPlayerBoard(playerIndex) {\n      const playerData = this.playersData[playerIndex];\n      const currentPlayer = playerIndex === this.currentPlayerIndex;\n      const disabled =\n        (this.allPlayersDisabled || currentPlayer) && this.gameStarted;\n      const playerTypeComputer =\n        playerData.player.type === Player.TYPES.COMPUTER;\n      const clickable = playerTypeComputer && !currentPlayer && !disabled;\n      const movable = !this.gameStarted && !this.allPlayersDisabled;\n      if ([...playerData.playerUI.children].length > 1) {\n        playerData.playerUI.removeChild(playerData.playerUI.lastChild);\n      }\n      playerData.playerUI.appendChild(\n        Board(\n          playerData.player.gameBoard,\n          playerData.player.type === Player.TYPES.COMPUTER,\n          disabled,\n          clickable,\n          movable,\n        ),\n      );\n    },\n    /**\n     * Renders the recent player's UI-information/board to the DOM\n     * @param {number} playerIndex\n     * @param {HTMLDivElement?} parentElement - Optional parent to append player's UI to it\n     */\n    renderPlayerUI(playerIndex, parentElement) {\n      const playerData = this.playersData[playerIndex];\n      [...playerData.playerUI.children].forEach((child) => child.remove());\n      this.renderPlayerInfo(playerIndex);\n      this.renderPlayerBoard(playerIndex);\n      if (parentElement) parentElement.append(playerData.playerUI);\n    },\n    /**\n     * Renders the recent ALL player's UIs-information/board to the DOM\n     * @param {HTMLDivElement} parentElement - Optional parent to append ALL player's UIs to it\n     */\n    renderAllPlayersUI(parentElement) {\n      for (let i = 0; i < this.playersData.length; i++) {\n        this.renderPlayerUI(i, parentElement);\n      }\n    },\n    /**\n     * Plays on a computer's turn\n     */\n    playIfComputerTurn() {\n      const currentPlayer = this.playersData[this.currentPlayerIndex].player;\n      if (currentPlayer.type === Player.TYPES.COMPUTER) {\n        setTimeout(() => {\n          currentPlayer.play();\n        }, 1000);\n      }\n    },\n    /**\n     * Checks whether the computer is the current player\n     */\n    isComputerCurrentPlayer() {\n      return (\n        this.playersData[this.currentPlayerIndex].player.type ===\n        Player.TYPES.COMPUTER\n      );\n    },\n  };\n}\n\nlet gameState = createNewState();\n\nlet evaluatingAttack = false;\n\n/** Handles ATTACK event */\nfunction attackHandler(cellPlacePair) {\n  if (!evaluatingAttack) {\n    evaluatingAttack = true;\n    const opponentIndex = gameState.currentPlayerIndex === 0 ? 1 : 0;\n    const opponentPlayer = gameState.playersData[opponentIndex].player;\n    opponentPlayer.gameBoard.receiveAttack(cellPlacePair);\n    evaluatingAttack = false;\n  }\n}\n\n/** Handles HIT event */\nfunction hitHandler() {\n  // Continue with the current player, but rerender the opponent's board\n  gameState.renderPlayerUI(gameState.currentPlayerIndex === 0 ? 1 : 0);\n  gameState.playIfComputerTurn();\n}\n\n/** Handles MISS event */\nfunction missHandler() {\n  gameState.switchCurrentPlayer();\n  gameState.renderAllPlayersUI();\n  gameState.playIfComputerTurn();\n}\n\n/** Handles LOSS event */\nfunction lossHandler() {\n  gameEvents.emit(gameEvents.GAME_OVER);\n}\n\n/** Handles SHIP_MOVED event */\nfunction shipMovedHandler() {\n  if (gameState.gameStarted) {\n    gameState.renderAllPlayersUI();\n  } else {\n    gameState.renderPlayerBoard(0);\n  }\n}\n\n/** Handles SHIP_ROTATED event */\nfunction shipRotatedHandler() {\n  shipMovedHandler();\n}\n\n/** Adds all game events' handlers */\nfunction addGameEventsHandlers() {\n  gameEvents.add(gameEvents.SHIP_ROTATED, shipRotatedHandler);\n  gameEvents.add(gameEvents.SHIP_MOVED, shipMovedHandler);\n  gameEvents.add(gameEvents.ATTACK, attackHandler);\n  gameEvents.add(gameEvents.HIT, hitHandler);\n  gameEvents.add(gameEvents.MISS, missHandler);\n  gameEvents.add(gameEvents.LOSS, lossHandler);\n}\n\n/** Removes all game events' handlers */\nfunction removeGameEventsHandlers() {\n  gameEvents.remove(gameEvents.SHIP_ROTATED, shipRotatedHandler);\n  gameEvents.remove(gameEvents.SHIP_MOVED, shipMovedHandler);\n  gameEvents.remove(gameEvents.ATTACK, attackHandler);\n  gameEvents.remove(gameEvents.HIT, hitHandler);\n  gameEvents.remove(gameEvents.MISS, missHandler);\n  gameEvents.remove(gameEvents.LOSS, lossHandler);\n}\n\n/**\n * Creates a game object to hold the state of the game\n * @returns @type {BattleshipGame}\n */\nexport default function createGame(gameContainer) {\n  return {\n    gameContainer,\n    initiateNewGame() {\n      removeGameEventsHandlers();\n      gameState = createNewState();\n      addGameEventsHandlers();\n      [...this.gameContainer.children].forEach((child) => child.remove());\n      gameState.renderPlayerUI(0, this.gameContainer);\n    },\n    /**\n     * - Resets game's state/events.\n     * - Rerenders the game's UI after removing the old UI from the game's container.\n     */\n    startGame() {\n      gameState.gameStarted = true;\n      [...this.gameContainer.children].forEach((child) => child.remove());\n      gameState.renderAllPlayersUI(this.gameContainer);\n    },\n    /** Checks whether the current player is the computer (should be called on a player's loss) */\n    isComputerWon() {\n      return gameState.isComputerCurrentPlayer();\n    },\n    /** Renders disabled UI */\n    endCurrentGame() {\n      gameState.gameStarted = false;\n      gameState.allPlayersDisabled = true;\n      gameState.renderAllPlayersUI();\n    },\n  };\n}\n\nexport { createGame };\n","import './index.css';\n\nimport { createElement } from '../../helpers/create-element';\nimport { capitalize } from '../../helpers/capitalize';\nimport { Player } from '../../player';\nimport gameEvents from '../../game-events';\n\n/**\n * Creates DOM element (div) that has the player's information\n * @param {string} name - The name of the player (hyphened not spaced)\n * @param {string} type - The type of the player\n * @param {Object} gameBoard - The player's game board\n * @returns {HTMLDivElement}\n */\nexport default function PlayerInfo(name, type, gameBoard) {\n  if (typeof name !== 'string') {\n    throw TypeError(\n      `Invalid 'name' type; expected: 'string', given: '${name}'`,\n    );\n  }\n\n  const playerInfo = createElement('div', `${name}-info`);\n\n  const nameIndicator = capitalize(name.replace('-', ' '));\n\n  const playerName = createElement('h3', 'player-name', `${nameIndicator}`);\n\n  playerInfo.append(playerName);\n\n  if (gameBoard && type === Player.TYPES.HUMAN) {\n    const shipNav = createElement('div', 'ship-nav');\n    const selectContainer = createElement('div', 'select-container');\n    const selectShip = createElement('select', 'select-ship', null, [\n      'name',\n      'select-ship',\n    ]);\n    selectShip.append(new Option('Select a ship', -1));\n    const shipsOptions = [];\n    gameBoard.shipsAreas.forEach((shipArea, i) => {\n      shipsOptions.push(new Option(''.padStart(shipArea.length, '◼'), i));\n      selectShip.append(shipsOptions.at(-1));\n    });\n    const [moveUpBtn, moveDownBtn, moveLeftBtn, moveRightBtn, rotateBtn] = [\n      createElement('button', 'move-up-btn', 'Up', ['type', 'button']),\n      createElement('button', 'move-down-btn', 'Down', ['type', 'button']),\n      createElement('button', 'move-left-btn', 'Left', ['type', 'button']),\n      createElement('button', 'move-right-btn', 'Right', ['type', 'button']),\n      createElement('button', 'move-rotate-btn', 'Rotate', ['type', 'button']),\n    ];\n    const moveHandler = (functionName) => {\n      if (selectShip.value) {\n        const shipAreaIndex = Number(selectShip.value);\n        if (\n          Number.isInteger(shipAreaIndex) &&\n          shipAreaIndex > -1 &&\n          shipAreaIndex < gameBoard.shipsAreas.length\n        ) {\n          gameBoard[functionName](shipAreaIndex);\n        }\n      }\n    };\n    moveUpBtn.addEventListener('click', () => moveHandler('moveShipUp'));\n    moveDownBtn.addEventListener('click', () => moveHandler('moveShipDown'));\n    moveLeftBtn.addEventListener('click', () => moveHandler('moveShipLeft'));\n    moveRightBtn.addEventListener('click', () => moveHandler('moveShipRight'));\n    rotateBtn.addEventListener('click', () => moveHandler('rotateShip'));\n    selectContainer.append(selectShip);\n    shipNav.append(\n      selectContainer,\n      moveUpBtn,\n      moveDownBtn,\n      moveLeftBtn,\n      moveRightBtn,\n      rotateBtn,\n    );\n    playerInfo.append(\n      createElement(\n        'p',\n        'ship-nav-description',\n        'Use these buttons (or drag-drop & double-click) to place a ship.',\n      ),\n      shipNav,\n    );\n    // Handle tha case when a ship selected by direct click on it.\n    gameEvents.add(gameEvents.SHIP_SELECTED, (shipAreaIndex) => {\n      shipsOptions.forEach((shipOption, i) => {\n        shipOption.selected = i === shipAreaIndex;\n      });\n    });\n  }\n\n  return playerInfo;\n}\n\nexport { PlayerInfo };\n","/**\n * Returns same string with the first character capitalized.\n * @param {string} text - Text to capitalize\n * @return {string} - Same string with first character capitalized\n */\nexport default function capitalize(text) {\n  const strText = String(text);\n  const strAfterFirst = strText.length > 1 ? strText.slice(1) : '';\n  return strText.charAt(0).toLocaleUpperCase() + strAfterFirst;\n}\n\nexport { capitalize };\n","import './index.css';\n\nimport { createElement } from './helpers/create-element';\nimport { createGame } from './helpers/create-game';\nimport { gameEvents } from './game-events';\n\nconst [headContainer, header, startGameBtn, resetGameBtn, gameContainer] = [\n  createElement('div', 'head-container'),\n  createElement('h1', 'head', 'Odin Battleship'),\n  createElement('button', 'start-btn control-btn', 'Start', ['type', 'button']),\n  createElement('button', 'reset-btn control-btn', 'Reset', ['type', 'button']),\n  createElement('div', 'game-container'),\n];\n\n// Initiate a game logic object\nconst game = createGame(gameContainer);\n\nlet gameOver = false;\n\nstartGameBtn.addEventListener('click', () => {\n  game.startGame();\n  headContainer.removeChild(startGameBtn);\n  headContainer.appendChild(resetGameBtn);\n});\n\nresetGameBtn.addEventListener('click', () => {\n  game.initiateNewGame();\n  headContainer.removeChild(resetGameBtn);\n  headContainer.appendChild(startGameBtn);\n  gameOver = false;\n});\n\ngameEvents.add(gameEvents.GAME_OVER, () => {\n  if (!gameOver) {\n    gameOver = true;\n    game.endCurrentGame();\n    const endMessage = game.isComputerWon() ? 'Game Over!' : 'You Win!';\n    const [dialog, message, question, cancelBtn, playAgainBtn] = [\n      createElement('dialog', 'game-over'),\n      createElement('h2', 'message', endMessage),\n      createElement('p', 'question', 'Do want to play again?'),\n      createElement('button', 'cancel-btn', 'Cancel', ['type', 'button']),\n      createElement('button', 'play-again-btn', 'Play Again', [\n        'type',\n        'button',\n      ]),\n    ];\n    dialog.addEventListener('close', () => document.body.removeChild(dialog));\n    cancelBtn.addEventListener('click', () => dialog.close());\n    playAgainBtn.addEventListener('click', () => {\n      game.initiateNewGame();\n      dialog.close();\n      resetGameBtn.click();\n    });\n    dialog.append(message, question, cancelBtn, playAgainBtn);\n    document.body.append(dialog);\n    dialog.showModal();\n  }\n});\n\ngame.initiateNewGame();\n\nheadContainer.append(header, startGameBtn);\ndocument.body.append(headContainer, gameContainer);\n"],"names":["createElement","tagName","className","textContent","_len","arguments","length","attrs","Array","_key","TypeError","element","document","isArray","flat","i","setAttribute","REGISTRY","add","eventName","callbacks","every","c","strArgs","concat","toString","replace","_REGISTRY$eventName","push","apply","remove","callback","filter","registeredCallback","emit","_len2","args","_key2","forEach","Object","freeze","prototype","gameEvents","ATTACK","HIT","MISS","LOSS","GAME_OVER","SHIP_MOVED","SHIP_ROTATED","SHIP_SELECTED","SHIP_IS_SUNK","Ship","Number","isInteger","hits","sunk","hit","isSunk","ship","setPrototypeOf","config","configurable","enumerable","configExt","_objectSpread","writable","defineProperties","constructor","value","get","oldBoardSetup","oldShips","GameBoard","computerBoard","BOARD_SIDE_LENGTH","board","j","attacked","missed","shipsAreas","getRandomUpToButNotIncluding","n","Math","floor","random","isEmptyCell","_ref","_ref2","_slicedToArray","getValidShipArea","firstCellPlace","direction","result","currentCellPlace","_toConsumableArray","randomizationFailed","insertShipInRandomBoardPlace","shipArea","loopsCount","movingAxis","fixedAxis","randomCellPlace","_ref3","_ref4","ships","splice","row","cell","shipIndex","findIndex","newShip","_ref5","_ref6","isCellOnBoard","_ref7","_ref8","cacheCustomBoard","cacheShips","resetBoard","moveShipAreaOnBoard","shipAreaIndex","newAreaToOccupy","_ref11","_ref12","emptyShipAreaOnBoard","shipAreaToEmpty","_ref13","_ref14","isValidMove","cellToOccupy","otherShipsAreas","_","some","moveShip","_ref15","_ref16","deltaI","deltaJ","areaToOccupy","usedShipArea","gameBoard","receiveAttack","_ref9","_ref10","indexOf","moveShipUp","moveShipDown","moveShipLeft","moveShipRight","occupiedCellPair","cellPairToOccupy","_occupiedCellPair","occupiedI","occupiedJ","_cellPairToOccupy","toOccupyI","toOccupyJ","occupiedCell","cellPair","rotateShip","midIndex","verticalShip","rotatedShipArea","_ref18","midPairConstSide","midPairVarSide","deltaCurrentIdex","abs","otherSide","unshift","defineProperty","Player","playerType","undefined","TYPES","COMPUTER","HUMAN","type","player","_player$gameBoard$boa","_player$gameBoard$boa2","maxHeight","maxWidth","opponentBoard","opponentSunkShipsAreas","highPriorityTargetsQ","mediumPriorityTargetsQ","target","validTargets","previousDirection","smartTarget","isPartOfSunkShip","sunkI","sunkJ","_target2","DIR_MOD","_defineProperty","DIRS_KEYS","axisModifiers","TOP","BOTTOM","LEFT","RIGHT","_loop","_opponentBoard$newI","modifier","k","newI","newJ","adjacentC","isExist","oldI","oldJ","firstCI","firstCJ","secondCI","secondCJ","_opponentBoard$firstC","_opponentBoard$second","firstC","secondC","shift","_target4","validAdjacentCellsOrNulls","validAdjacentCellsIndexes","dirMod","adjacentCellPair","_opponentBoard$i","opponentCell","isValidTarget","includes","sunkShipArea","shipCellPair","play","randomTargetIndex","isEqualToGivenTarget","savedI","savedJ","highPriorityIndex","mediumPriorityIndex","validTargetIndex","removeFromPrioritizedAndValidTargets","heldCellPair","heldShipAreaIndex","pointerUpTwice","createNewState","playersData","name","playerUI","currentPlayerIndex","allPlayersDisabled","gameStarted","switchCurrentPlayer","this","renderPlayerInfo","playerIndex","playerData","oldChildren","children","child","append","text","strText","strAfterFirst","playerInfo","nameIndicator","String","slice","charAt","toLocaleUpperCase","playerName","shipNav","selectContainer","selectShip","Option","shipsOptions","padStart","at","moveUpBtn","moveDownBtn","moveLeftBtn","moveRightBtn","rotateBtn","moveHandler","functionName","addEventListener","shipOption","selected","PlayerInfo","appendChild","renderPlayerBoard","currentPlayer","disabled","clickable","movable","removeChild","lastChild","playerGameBoard","hidden","arg","boardWidth","findShipAreaIndex","cellShipAreaIndex","held","boardCell","holdBoardCell","event","button","pointerType","preventDefault","releaseHeldCell","setTimeout","moveHeldShip","pairToOccupy","onpointerdown","window","navigator","maxTouchPoints","e","releasePointerCapture","pointerId","console","log","message","passive","style","display","gridTemplateColumns","gridTemplateRows","Board","renderPlayerUI","parentElement","renderAllPlayersUI","playIfComputerTurn","isComputerCurrentPlayer","gameState","evaluatingAttack","attackHandler","cellPlacePair","opponentIndex","hitHandler","missHandler","lossHandler","shipMovedHandler","shipRotatedHandler","headContainer","header","startGameBtn","resetGameBtn","gameContainer","game","initiateNewGame","startGame","isComputerWon","endCurrentGame","createGame","gameOver","endMessage","dialog","question","cancelBtn","playAgainBtn","body","close","click","showModal"],"sourceRoot":""}